const express = require('express');
const cors = require('cors');
require('dotenv').config();

const { authenticate: verifyToken, requirePermission } = require('./middleware/auth');
const { testConnections } = require('./config/database');
const nominasService = require('./services/nominasService');
const fondosService = require('./services/fondosService');
const uploadService = require('./services/uploadService');
const payrollFilterService = require('./services/payrollFilterService'); // Mover aquÃ­
const multer = require('multer');

// Configure multer for file uploads
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 50 * 1024 * 1024, // 50MB limit
  },
  fileFilter: (req, file, cb) => {
    // Accept Excel and CSV files
    if (file.mimetype === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' || 
        file.mimetype === 'text/csv') {
      cb(null, true);
    } else {
      cb(new Error('Solo se permiten archivos Excel (.xlsx) o CSV (.csv)'));
    }
  }
});

const app = express();
const PORT = process.env.PORT || 3001;

// Middleware global
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// ConfiguraciÃ³n CORS
const corsOptions = {
  origin: process.env.CORS_ORIGINS ? process.env.CORS_ORIGINS.split(',') : [
    'http://localhost:5173',
    'http://localhost:3000', 
    'http://localhost:3002',
    'http://localhost:3003'
  ],
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true
};
app.use(cors(corsOptions));

// Middleware de logging
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
  next();
});

// ============================================================================
// RUTAS PÃšBLICAS
// ============================================================================

// Endpoint de compatibilidad para bÃºsqueda de empleados (usado por el frontend)
app.get('/busqueda-empleados', async (req, res) => {
  try {
    const { pageSize, page, search, puesto, compania, sucursal, status, puestoCategorizado, cveper, orderBy, orderDirection } = req.query;
    
    console.log('ðŸ” /busqueda-empleados: ParÃ¡metros recibidos:', req.query);
    
    // Usar el mismo servicio que /api/payroll
    const result = await payrollFilterService.getPayrollDataWithFiltersAndSorting({
      pageSize: parseInt(pageSize) || 100,
      page: parseInt(page) || 1,
      search,
      puesto,
      compania,
      sucursal,
      status,
      puestoCategorizado,
      cveper,
      orderBy,
      orderDirection
    });
    
    console.log('âœ… /busqueda-empleados: Datos obtenidos exitosamente:', {
      records: result.data?.length || 0,
      total: result.pagination?.total || 0
    });
    
    res.json(result);
  } catch (error) {
    console.error('âŒ Error en bÃºsqueda de empleados:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Health check
app.get('/health', async (req, res) => {
  try {
    const connections = await testConnections();
    res.json({
      status: 'OK',
      timestamp: new Date().toISOString(),
      connections: connections,
      environment: process.env.NODE_ENV || 'development'
    });
  } catch (error) {
    res.status(500).json({
      status: 'ERROR',
      message: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Info de la API
app.get('/api/info', (req, res) => {
  res.json({
    name: 'Historic Data API',
    version: '1.0.0',
    description: 'API para consultar datos histÃ³ricos de nÃ³minas y fondos',
    endpoints: {
      public: ['/health', '/api/info'],
      protected: {
        nominas: ['/api/nominas/*'],
        fondos: ['/api/fondos/*']
      },
      permissions: {
        'custom:can_upload': 'Permite subir archivos',
        'custom:can_view_funds': 'Permite ver informaciÃ³n de fondos',
        'custom:role': 'admin | user'
      }
    }
  });
});

// ============================================================================
// MIDDLEWARE DE AUTENTICACIÃ“N
// ============================================================================

// Middleware de autenticaciÃ³n que se aplicarÃ¡ manualmente a las rutas protegidas

// ============================================================================
// RUTAS DE NÃ“MINAS - Requiere autenticaciÃ³n
// ============================================================================

// Obtener tablas disponibles en base de datos de nÃ³minas
app.get('/api/nominas/tables', verifyToken, async (req, res) => {
  try {
    const result = await nominasService.getTables();
    res.json(result);
  } catch (error) {
    console.error('âŒ Error en /api/nominas/tables:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Obtener estructura de una tabla especÃ­fica
app.get('/api/nominas/tables/:tableName/structure', verifyToken, async (req, res) => {
  try {
    const { tableName } = req.params;
    const result = await nominasService.getTableStructure(tableName);
    res.json(result);
  } catch (error) {
    console.error('âŒ Error obteniendo estructura de tabla:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Consultar datos de una tabla con paginaciÃ³n y filtros
app.get('/api/nominas/tables/:tableName/data', verifyToken, async (req, res) => {
  try {
    const { tableName } = req.params;
    const { limit, offset, orderBy, order, ...filters } = req.query;
    
    // Construir filtros WHERE si se proporcionan
    const where = [];
    Object.entries(filters).forEach(([key, value]) => {
      if (value && key !== 'limit' && key !== 'offset' && key !== 'orderBy' && key !== 'order') {
        where.push({
          column: key,
          value: value,
          operator: 'ILIKE' // Para bÃºsquedas de texto parcial
        });
      }
    });
    
    const options = {
      limit,
      offset,
      orderBy,
      order,
      where: where.length > 0 ? where : undefined
    };
    
    const result = await nominasService.queryTable(tableName, options);
    res.json(result);
  } catch (error) {
    console.error('âŒ Error consultando tabla:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Buscar empleados
app.get('/api/nominas/search/employees', verifyToken, async (req, res) => {
  try {
    const { q: searchTerm, limit, offset } = req.query;
    
    if (!searchTerm) {
      return res.status(400).json({
        success: false,
        error: 'ParÃ¡metro de bÃºsqueda "q" es requerido'
      });
    }
    
    const result = await nominasService.searchEmployees(searchTerm, { limit, offset });
    res.json(result);
  } catch (error) {
    console.error('âŒ Error buscando empleados:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Obtener estadÃ­sticas de nÃ³minas
app.get('/api/nominas/stats', verifyToken, async (req, res) => {
  try {
    const result = await nominasService.getStats();
    res.json(result);
  } catch (error) {
    console.error('âŒ Error obteniendo estadÃ­sticas de nÃ³minas:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Obtener valores Ãºnicos de una columna para filtros
app.get('/api/nominas/unique/:tableName/:columnName', verifyToken, async (req, res) => {
  try {
    const { tableName, columnName } = req.params;
    const { search, limit } = req.query;
    
    const result = await nominasService.getUniqueValues(tableName, columnName, {
      search,
      limit
    });
    res.json(result);
  } catch (error) {
    console.error('âŒ Error obteniendo valores Ãºnicos:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Obtener Ãºltimo periodo disponible
app.get('/api/nominas/latest-period', verifyToken, async (req, res) => {
  try {
    const result = await nominasService.getLatestPeriod();
    res.json(result);
  } catch (error) {
    console.error('âŒ Error obteniendo Ãºltimo periodo:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// RUTAS ESPECÃFICAS DE PAYROLL - DEBEN IR ANTES QUE LA RUTA GENERAL
// ============================================================================

// Obtener todas las categorÃ­as de puestos disponibles (sin autenticaciÃ³n para desarrollo)
app.get('/api/payroll/categorias-puestos', async (req, res) => {
  try {
    const categorias = nominasService.getPuestosCategorias();
    
    // Formatear para el DropDownMenu (incluir conteos)
    const categoriasConConteo = categorias.map(categoria => ({
      value: categoria,
      count: 0 // El conteo real se calcularÃ¡ cuando se implemente el filtrado completo
    }));
    
    res.json({
      success: true,
      data: categoriasConConteo,
      count: categorias.length
    });
  } catch (error) {
    console.error('âŒ Error obteniendo categorÃ­as de puestos:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Obtener categorÃ­a de un puesto especÃ­fico
app.get('/api/payroll/puesto-categoria/:puesto', async (req, res) => {
  try {
    const { puesto } = req.params;
    const categoria = nominasService.getPuestoCategorizado(puesto);
    
    res.json({
      success: true,
      puesto: puesto,
      categoria: categoria
    });
  } catch (error) {
    console.error('âŒ Error obteniendo categorÃ­a del puesto:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Obtener estadÃ­sticas completas de payroll
app.get('/api/payroll/stats', async (req, res) => {
  try {
    const result = await nominasService.getDatasetStats();
    res.json({
      success: true,
      stats: result // Asegurar que estÃ¡ envuelto en la estructura esperada
    });
  } catch (error) {
    console.error('âŒ Error obteniendo estadÃ­sticas de payroll:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Obtener periodos Ãºnicos (cveper) desde payroll_data
app.get('/api/payroll/periodos', async (req, res) => {
  try {
    const result = await nominasService.getUniquePayrollPeriods();
    res.json(result);
  } catch (error) {
    console.error('âŒ Error obteniendo periodos de payroll:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// NUEVO: Obtener filtros con cardinalidad en tiempo real
app.get('/api/payroll/filters', async (req, res) => {
  console.log('ðŸ” DEBUG: Accediendo a /api/payroll/filters');
  console.log('ðŸ” DEBUG: Query params:', req.query);
  
  try {
    // Extraer filtros activos de los parÃ¡metros de consulta
    const activeFilters = {};
    
    if (req.query.search) activeFilters.search = req.query.search;
    if (req.query.sucursal) {
      activeFilters.sucursal = Array.isArray(req.query.sucursal) ? req.query.sucursal : [req.query.sucursal];
    }
    if (req.query.puesto) {
      activeFilters.puesto = Array.isArray(req.query.puesto) ? req.query.puesto : [req.query.puesto];
    }
    if (req.query.status) {
      activeFilters.status = Array.isArray(req.query.status) ? req.query.status : [req.query.status];
    }
    if (req.query.cveper) activeFilters.cveper = req.query.cveper;
    if (req.query.puestoCategorizado) {
      activeFilters.puestoCategorizado = Array.isArray(req.query.puestoCategorizado) 
        ? req.query.puestoCategorizado : [req.query.puestoCategorizado];
    }
    
    console.log('ðŸ” DEBUG: Active filters:', activeFilters);
    
    const result = await payrollFilterService.getFiltersWithCardinality(activeFilters);
    
    console.log('âœ… DEBUG: Filtros obtenidos exitosamente:', {
      sucursales: result.data?.sucursales?.length || 0,
      puestos: result.data?.puestos?.length || 0,
      estados: result.data?.estados?.length || 0
    });
    
    res.json(result);
  } catch (error) {
    console.error('âŒ Error obteniendo filtros con cardinalidad:', error);
    res.status(500).json({
      success: false,
      error: error.message,
      stack: process.env.NODE_ENV !== 'production' ? error.stack : undefined
    });
  }
});

// Endpoint especÃ­fico para tabla demogrÃ¡fica con server-side sorting
app.get('/api/payroll/demographic', async (req, res) => {
  try {
    const { page, pageSize, sortBy, sortDir, search, puesto, sucursal, status, puestoCategorizado, cveper } = req.query;
    
    console.log('ðŸ“Š /api/payroll/demographic: ParÃ¡metros recibidos:', {
      page, pageSize, sortBy, sortDir, cveper
    });
    
    // DEBUGGING ESPECIAL para cveper
    if (cveper) {
      console.log('ðŸ“… DEBUGGING CVEPER en demographic:', {
        cveper,
        tipoCveper: typeof cveper,
        esArray: Array.isArray(cveper),
        longitud: cveper.length,
        formatoYYYY_MM: /^\d{4}-\d{2}$/.test(cveper),
        formatoYYYY_MM_DD: /^\d{4}-\d{2}-\d{2}$/.test(cveper)
      });
    }
    
    // Usar el mismo servicio que /api/payroll para consistencia COMPLETA
    const result = await payrollFilterService.getPayrollDataWithFiltersAndSorting({
      pageSize: parseInt(pageSize) || 50,
      page: parseInt(page) || 1,
      orderBy: sortBy || 'nombre',
      orderDirection: sortDir || 'asc',
      // AÃ‘ADIR TODOS LOS FILTROS
      search,
      puesto,
      sucursal,
      status,
      puestoCategorizado,
      cveper  // Â¡ESTE ERA EL FILTRO FALTANTE!
    });
    
    console.log('âœ… /api/payroll/demographic: Datos obtenidos exitosamente:', {
      records: result.data?.length || 0,
      total: result.pagination?.total || 0,
      filtroAplicado: cveper ? `cveper=${cveper}` : 'sin filtro'
    });
    
    res.json({
      success: true,
      data: result.data,
      total: result.pagination?.total || 0,
      page: parseInt(page) || 1,
      pageSize: parseInt(pageSize) || 50
    });
  } catch (error) {
    console.error('âŒ Error obteniendo datos demogrÃ¡ficos:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// NUEVO: Obtener conteo de empleados Ãºnicos (CURPs Ãºnicos) con filtros
app.get('/api/payroll/demographic/unique-count', async (req, res) => {
  try {
    const { search, puesto, sucursal, status, puestoCategorizado, cveper } = req.query;
    
    console.log('ðŸ”¢ /api/payroll/demographic/unique-count: ParÃ¡metros recibidos:', {
      search, puesto, sucursal, status, puestoCategorizado, cveper
    });
    
    const { nominasPool } = require('./config/database');
    const client = await nominasPool.connect();
    
    let query = `
      SELECT COUNT(DISTINCT "CURP") as unique_count
      FROM historico_nominas_gsau
      WHERE "CURP" IS NOT NULL AND "CURP" != ''
    `;
    
    const params = [];
    let paramIndex = 1;
    
    // Aplicar filtro de perÃ­odo si se proporciona
    if (cveper) {
      if (cveper.match(/^\d{4}-\d{2}$/)) {
        query += ` AND DATE_TRUNC('month', cveper) = $${paramIndex}`;
        params.push(`${cveper}-01`);
      } else if (cveper.match(/^\d{4}-\d{2}-\d{2}$/)) {
        query += ` AND DATE(cveper) = $${paramIndex}`;
        params.push(cveper);
      }
      paramIndex++;
    }
    
    // Aplicar filtro de estado si se proporciona
    if (status) {
      query += ` AND "Status" = $${paramIndex}`;
      if (status === 'Activo') {
        params.push('A');
      } else if (status === 'Baja') {
        params.push('B');
      } else if (status === 'Finiquito') {
        params.push('F');
      }
      paramIndex++;
    }
    
    // Aplicar otros filtros si se proporcionan
    if (search) {
      const searchPattern = `%${search}%`;
      query += ` AND ("Nombre completo" ILIKE $${paramIndex} OR "CURP" ILIKE $${paramIndex})`;
      params.push(searchPattern);
      paramIndex++;
    }
    
    if (puesto) {
      query += ` AND "Puesto" ILIKE $${paramIndex}`;
      params.push(`%${puesto}%`);
      paramIndex++;
    }
    
    if (sucursal) {
      query += ` AND "CompaÃ±Ã­a" ILIKE $${paramIndex}`;
      params.push(`%${sucursal}%`);
      paramIndex++;
    }
    
    console.log('ðŸ”¢ Query para conteo CURPs Ãºnicos:', query);
    console.log('ðŸ“‹ ParÃ¡metros:', params);
    
    const result = await client.query(query, params);
    client.release();
    
    const uniqueCurpCount = parseInt(result.rows[0]?.unique_count || 0);
    
    console.log('âœ… Conteo CURPs Ãºnicos:', uniqueCurpCount);
    
    res.json({
      success: true,
      uniqueCurpCount
    });
  } catch (error) {
    console.error('âŒ Error obteniendo conteo de CURPs Ãºnicos:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// ENDPOINT DE PERCEPCIONES - Para componente Percepciones
// ============================================================================

// Obtener datos de percepciones de un empleado especÃ­fico por CURP y CVEPER
app.get('/api/percepciones', async (req, res) => {
  try {
    const { curp, cveper, pageSize = '10', page = '1' } = req.query;
    
    console.log('ðŸ’° /api/percepciones: ParÃ¡metros recibidos:', { curp, cveper, pageSize, page });
    
    if (!curp) {
      return res.status(400).json({
        success: false,
        error: 'CURP es requerido'
      });
    }

    // Conectar directamente a la base de datos para obtener todos los campos
    const { nominasPool } = require('./config/database');
    const client = await nominasPool.connect();
    
    let query = `
      SELECT *
      FROM historico_nominas_gsau
      WHERE "CURP" = $1
    `;
    
    const params = [curp];
    let paramIndex = 2;
    
    // Aplicar filtro de perÃ­odo si se proporciona
    if (cveper) {
      if (cveper.match(/^\d{4}-\d{2}-\d{2}$/)) {
        query += ` AND DATE(cveper) = $${paramIndex}`;
        params.push(cveper);
      } else if (cveper.match(/^\d{4}-\d{2}$/)) {
        query += ` AND DATE_TRUNC('month', cveper) = $${paramIndex}`;
        params.push(`${cveper}-01`);
      } else {
        query += ` AND cveper = $${paramIndex}`;
        params.push(cveper);
      }
      paramIndex++;
    }
    
    // Ordenar por perÃ­odo mÃ¡s reciente primero
    query += ` ORDER BY cveper DESC LIMIT $${paramIndex}`;
    params.push(parseInt(pageSize));
    
    console.log('ðŸ” Query para percepciones:', query);
    console.log('ðŸ“‹ ParÃ¡metros:', params);
    
    const result = await client.query(query, params);
    client.release();
    
    console.log('âœ… /api/percepciones: Datos completos obtenidos:', {
      records: result.rows?.length || 0,
      curp: curp,
      cveper: cveper || 'sin filtro de perÃ­odo',
      columnsCount: result.fields?.length || 0
    });
    
    res.json({
      success: true,
      data: result.rows,
      pagination: {
        total: result.rows.length,
        page: parseInt(page),
        pageSize: parseInt(pageSize),
        totalPages: Math.ceil(result.rows.length / parseInt(pageSize))
      }
    });
  } catch (error) {
    console.error('âŒ Error obteniendo datos de percepciones:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// RUTA GENERAL DE PAYROLL - DEBE IR AL FINAL
// ============================================================================

// Obtener datos de empleados con filtros (sin autenticaciÃ³n para desarrollo)
app.get('/api/payroll', async (req, res) => {
  try {
    const { pageSize, page, search, puesto, compania, sucursal, status, puestoCategorizado, cveper, orderBy, orderDirection } = req.query;
    
    console.log('ðŸ” /api/payroll: ParÃ¡metros recibidos (RAW):', req.query);
    console.log('ðŸ” /api/payroll: ParÃ¡metros destructurados:', { 
      pageSize, page, search, puesto, compania, sucursal, status, 
      puestoCategorizado, cveper, orderBy, orderDirection 
    });
    
    // DEBUGGING ESPECIAL para cveper
    if (cveper) {
      console.log('ðŸ—“ï¸ DEBUGGING CVEPER:', {
        cveper,
        tipoCveper: typeof cveper,
        esArray: Array.isArray(cveper),
        longitud: cveper.length,
        formatoYYYY_MM: /^\d{4}-\d{2}$/.test(cveper),
        formatoYYYY_MM_DD: /^\d{4}-\d{2}-\d{2}$/.test(cveper)
      });
    }
    
    // NUEVO: Usar payrollFilterService para un sorting mÃ¡s preciso
    const result = await payrollFilterService.getPayrollDataWithFiltersAndSorting({
      pageSize: parseInt(pageSize) || 100,
      page: parseInt(page) || 1,
      search,
      puesto,
      compania, // Para compatibilidad hacia atrÃ¡s
      sucursal, // Para nuevo sistema de filtros
      status,
      puestoCategorizado,
      cveper,
      orderBy, // Campo por el cual ordenar
      orderDirection // DirecciÃ³n del ordenamiento (asc/desc)
    });
    
    console.log('âœ… /api/payroll: Datos obtenidos exitosamente:', {
      records: result.data?.length || 0,
      total: result.pagination?.total || 0
    });
    
    res.json(result);
  } catch (error) {
    console.error('âŒ Error obteniendo datos de nÃ³mina:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// TEMPORAL: Consultar tabla historico_fondos_gsau (sin autenticaciÃ³n para desarrollo)
app.get('/api/historico-fondos/check', async (req, res) => {
  try {
    const result = await fondosService.getHistoricoFondosData();
    res.json(result);
  } catch (error) {
    console.error('âŒ Error consultando historico_fondos_gsau:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// TEMPORAL: Listar todas las tablas de fondos (sin autenticaciÃ³n para desarrollo)
app.get('/api/fondos-tables/list', async (req, res) => {
  try {
    const result = await fondosService.getTables();
    res.json(result);
  } catch (error) {
    console.error('âŒ Error obteniendo tablas de fondos:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// TEMPORAL: Consultar tabla fondos_data especÃ­ficamente (sin autenticaciÃ³n para desarrollo)
app.get('/api/fondos-data/check', async (req, res) => {
  try {
    const result = await fondosService.getFondosDataInfo();
    res.json(result);
  } catch (error) {
    console.error('âŒ Error consultando fondos_data:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Obtener datos de empleados con filtros (versiÃ³n autenticada)
app.post('/api/nominas/employees', verifyToken, async (req, res) => {
  try {
    const filters = req.body;
    const result = await nominasService.getEmployeesData(filters);
    res.json(result);
  } catch (error) {
    console.error('âŒ Error obteniendo datos de empleados:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// RUTAS DE FONDOS - Requiere autenticaciÃ³n + permiso can_view_funds
// ============================================================================

// Middleware para verificar permisos de fondos
const requireFundsPermission = requirePermission('view_funds');

// Obtener tablas disponibles en base de datos de fondos
app.get('/api/fondos/tables', verifyToken, requireFundsPermission, async (req, res) => {
  try {
    const result = await fondosService.getTables();
    res.json(result);
  } catch (error) {
    console.error('âŒ Error en /api/fondos/tables:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Obtener estructura de una tabla de fondos
app.get('/api/fondos/tables/:tableName/structure', verifyToken, requireFundsPermission, async (req, res) => {
  try {
    const { tableName } = req.params;
    const result = await fondosService.getTableStructure(tableName);
    res.json(result);
  } catch (error) {
    console.error('âŒ Error obteniendo estructura de tabla de fondos:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Consultar datos de una tabla de fondos
app.get('/api/fondos/tables/:tableName/data', verifyToken, requireFundsPermission, async (req, res) => {
  try {
    const { tableName } = req.params;
    const { limit, offset, orderBy, order, ...filters } = req.query;
    
    const where = [];
    Object.entries(filters).forEach(([key, value]) => {
      if (value && key !== 'limit' && key !== 'offset' && key !== 'orderBy' && key !== 'order') {
        where.push({
          column: key,
          value: value,
          operator: 'ILIKE'
        });
      }
    });
    
    const options = {
      limit,
      offset,
      orderBy,
      order,
      where: where.length > 0 ? where : undefined
    };
    
    const result = await fondosService.queryTable(tableName, options);
    res.json(result);
  } catch (error) {
    console.error('âŒ Error consultando tabla de fondos:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Buscar fondos
app.get('/api/fondos/search', verifyToken, requireFundsPermission, async (req, res) => {
  try {
    const { q: searchTerm, limit, offset } = req.query;
    
    if (!searchTerm) {
      return res.status(400).json({
        success: false,
        error: 'ParÃ¡metro de bÃºsqueda "q" es requerido'
      });
    }
    
    const result = await fondosService.searchFunds(searchTerm, { limit, offset });
    res.json(result);
  } catch (error) {
    console.error('âŒ Error buscando fondos:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Obtener resumen financiero de fondos
app.get('/api/fondos/summary', verifyToken, requireFundsPermission, async (req, res) => {
  try {
    const result = await fondosService.getFinancialSummary();
    res.json(result);
  } catch (error) {
    console.error('âŒ Error obteniendo resumen financiero:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Obtener movimientos de fondos con filtros
app.get('/api/fondos/movements', verifyToken, requireFundsPermission, async (req, res) => {
  try {
    const { fechaInicio, fechaFin, tipoMovimiento, limit, offset } = req.query;
    
    const options = {
      fechaInicio,
      fechaFin,
      tipoMovimiento,
      limit,
      offset
    };
    
    const result = await fondosService.getMovements(options);
    res.json(result);
  } catch (error) {
    console.error('âŒ Error obteniendo movimientos de fondos:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Obtener estadÃ­sticas de fondos
app.get('/api/fondos/stats', verifyToken, requireFundsPermission, async (req, res) => {
  try {
    const result = await fondosService.getStats();
    res.json(result);
  } catch (error) {
    console.error('âŒ Error obteniendo estadÃ­sticas de fondos:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// RUTAS ADMINISTRATIVAS - Solo para administradores
// ============================================================================

const requireAdminRole = requirePermission('admin');

// InformaciÃ³n del usuario autenticado
app.get('/api/user/profile', verifyToken, (req, res) => {
  res.json({
    success: true,
    user: {
      sub: req.user.sub,
      email: req.user.email,
      username: req.user['cognito:username'],
      role: req.user.permissions?.role,
      permissions: req.user.permissions
    }
  });
});

// Endpoint administrativo para pruebas
app.get('/api/admin/test', verifyToken, requireAdminRole, async (req, res) => {
  try {
    const [nominasStats, fondosStats] = await Promise.all([
      nominasService.getStats(),
      fondosService.getStats()
    ]);
    
    res.json({
      success: true,
      message: 'Acceso administrativo confirmado',
      user: req.user['cognito:username'],
      statistics: {
        nominas: nominasStats,
        fondos: fondosStats
      },
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('âŒ Error en endpoint administrativo:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// ============================================================================
// RUTAS DE UPLOAD - Requiere autenticaciÃ³n
// ============================================================================

// Validar archivo Excel y detectar formato
app.post('/api/validate-file', upload.single('file'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No se proporcionÃ³ ningÃºn archivo'
      });
    }

    const result = await uploadService.validateFile(req.file.buffer, req.file.mimetype);
    
    if (result.success) {
      res.json({
        success: true,
        type: result.type,
        headers: result.headers,
        rowCount: result.rowCount,
        mappingValidation: result.mappingValidation,
        message: result.message
      });
    } else {
      res.status(400).json({
        success: false,
        message: result.message
      });
    }
  } catch (error) {
    console.error('âŒ Error validando archivo:', error);
    res.status(500).json({
      success: false,
      message: `Error del servidor: ${error.message}`
    });
  }
});

// Subir datos a la base de datos
app.post('/api/upload-data', upload.single('file'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No se proporcionÃ³ ningÃºn archivo'
      });
    }

    const { type } = req.body;
    
    if (!type || (type !== 'nominas' && type !== 'fondos')) {
      return res.status(400).json({
        success: false,
        message: 'Tipo de archivo no vÃ¡lido. Debe ser "nominas" o "fondos"'
      });
    }

    console.log(`ðŸ“ Procesando archivo de ${type}: ${req.file.originalname}`);
    
    const result = await uploadService.uploadData(req.file.buffer, type, req.file.mimetype);
    
    if (result.success) {
      console.log(`âœ… Upload exitoso: ${result.recordsInserted} registros insertados`);
      res.json({
        success: true,
        recordsInserted: result.recordsInserted,
        duplicatesSkipped: result.duplicatesSkipped,
        errors: result.errors || [],
        message: result.message
      });
    } else {
      res.status(400).json({
        success: false,
        message: result.message
      });
    }
  } catch (error) {
    console.error('âŒ Error subiendo datos:', error);
    res.status(500).json({
      success: false,
      message: `Error del servidor: ${error.message}`
    });
  }
});

// ============================================================================
// MANEJO DE ERRORES GLOBAL
// ============================================================================

// Manejo global de errores (debe estar antes que las rutas no encontradas)
app.use((error, req, res, next) => {
  console.error('âŒ Error global capturado:', error);
  
  res.status(error.status || 500).json({
    success: false,
    error: process.env.NODE_ENV === 'production' ? 'Error interno del servidor' : error.message,
    ...(process.env.NODE_ENV !== 'production' && { stack: error.stack })
  });
});

// Manejo de rutas no encontradas (debe estar al final)
app.use((req, res) => {
  res.status(404).json({
    success: false,
    error: 'Endpoint no encontrado',
    path: req.originalUrl,
    method: req.method
  });
});

// ============================================================================
// INICIO DEL SERVIDOR
// ============================================================================

const startServer = async () => {
  try {
    // Probar conexiones a las bases de datos
    console.log('ðŸ”„ Probando conexiones a bases de datos...');
    const connections = await testConnections();
    
    console.log('âœ… Estado de conexiones:');
    Object.entries(connections).forEach(([db, status]) => {
      console.log(`   ${db}: ${status.success ? 'âœ… Conectado' : 'âŒ Error - ' + status.error}`);
    });
    
    // Iniciar servidor
    app.listen(PORT, () => {
      console.log(`ðŸš€ Servidor API ejecutÃ¡ndose en puerto ${PORT}`);
      console.log(`ðŸŒ URL base: http://localhost:${PORT}`);
      console.log(`ðŸ“Š Health check: http://localhost:${PORT}/health`);
      console.log(`â„¹ï¸  Info de API: http://localhost:${PORT}/api/info`);
      console.log(`ðŸ”’ Rutas protegidas requieren JWT token de AWS Cognito`);
      console.log(`ðŸ“ Logs: ${new Date().toISOString()}`);
    });
    
  } catch (error) {
    console.error('âŒ Error al iniciar servidor:', error);
    process.exit(1);
  }
};

// Inicializar servidor
startServer();

// Manejo graceful de cierre
process.on('SIGTERM', () => {
  console.log('ðŸ›‘ Recibida seÃ±al SIGTERM, cerrando servidor...');
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('ðŸ›‘ Recibida seÃ±al SIGINT (Ctrl+C), cerrando servidor...');
  process.exit(0);
});

module.exports = app;
